pipeline {
    agent any

    environment {
        // --- Repository and Image Information ---
        IMAGE_NAME = 'rani19/backend' // Your Docker Hub username/repo for the backend
        TAG = "build-${env.BUILD_NUMBER}" // Unique tag for each build
        DEV_REPO_URL = 'https://github.com/RaniSaed/smart-retail-dev.git'
        CONFIG_REPO_URL = 'https://github.com/RaniSaed/smart-retail-config.git'

        // --- Credential IDs (configured in Jenkins) ---
        DOCKER_CREDENTIALS_ID = 'docker-hub-creds' // Docker Hub username/password
        SLACK_CREDENTIAL_ID = 'slack-webhook'     // Slack incoming webhook URL
        GITHUB_PUSH_TOKEN_ID = 'github-push-token' // GitHub Personal Access Token for config repo push

        // --- Docker Image Names for Deployment ---
        // Image for both main (3000) and DR (3002) frontends
        FRONTEND_IMAGE = 'rani19/gogo-main-frontend:latest' // IMPORTANT: Replace with your actual frontend image name
        // Image for the DR backend (5002). This will be the image built by THIS pipeline.
        DR_BACKEND_IMAGE = "${IMAGE_NAME}:${TAG}"
        // Note: 'gogo-main-backend' (5001) is assumed to be running outside this pipeline's direct control
        // and uses an image like 'smart-retail-dev-backend' for its operation.

        // --- Variables for Reporting DR Status (initial defaults) ---
        ACTIVE_FRONTEND_NAME = "UNKNOWN"
        ACTIVE_FRONTEND_PORT = "UNKNOWN"
        ACTIVE_BACKEND_NAME = "UNKNOWN" // K8s-Backend (5000) or gogo-dr-backend (5002)
        ACTIVE_BACKEND_PORT = "UNKNOWN"
        DR_FRONTEND_STATUS = "UNKNOWN"
        DR_BACKEND_STATUS = "UNKNOWN"
        DR_DATA_SYNC_STATUS = "UNKNOWN"
        FRONTEND_API_URL_USED = "UNKNOWN"
        CI_MAIN_BACKEND_PRECHECK_STATUS = "NOT CHECKED"
        DR_TEST_RESULT = "FAILURE" // Default to failure, set to SUCCESS if all logic passes
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '5')) // Keep last 5 successful builds
        timeout(time: 25, unit: 'MINUTES') // Increased timeout for comprehensive checks
    }

    stages {
        stage('üì• Clone Dev Repo') {
            steps {
                dir('dev') {
                    git url: "${DEV_REPO_URL}", branch: 'main'
                }
            }
        }

        stage('üìÅ Clone Config Repo') {
            steps {
                dir('config') {
                    git url: "${CONFIG_REPO_URL}", branch: 'main'
                }
            }
        }

        stage('üïµÔ∏è Check Backend Changes') {
            steps {
                dir('dev') {
                    script {
                        // Check if the 'backend/' directory has changes compared to the previous commit
                        def backendChanged = sh(
                            script: "git diff --name-only HEAD~1 HEAD | grep -q '^backend/'",
                            returnStatus: true
                        ) == 0

                        if (!backendChanged) {
                            echo "‚ö†Ô∏è No changes detected in the 'backend/' directory. Aborting pipeline as per logic."
                            currentBuild.result = 'ABORTED'
                            error("No changes in backend/ directory. Pipeline aborted.")
                        } else {
                            echo "‚úÖ Changes detected in 'backend/' directory. Proceeding with CI/CD."
                        }
                    }
                }
            }
        }

        stage('üê≥ Build Docker Image (Backend)') {
            steps {
                dir('dev') {
                    script {
                        echo "üì¶ Building Docker image: ${IMAGE_NAME}:${TAG} from backend/Dockerfile"
                        docker.build("${IMAGE_NAME}:${TAG}", "-f backend/Dockerfile backend")
                    }
                }
            }
        }

        stage('üöÄ Push to Docker Hub') {
            steps {
                withCredentials([usernamePassword(credentialsId: "${DOCKER_CREDENTIALS_ID}", usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                    script {
                        docker.withRegistry("https://index.docker.io/v1/", "${DOCKER_CREDENTIALS_ID}") {
                            echo "‚¨ÜÔ∏è Pushing image ${IMAGE_NAME}:${TAG} to Docker Hub..."
                            docker.image("${IMAGE_NAME}:${TAG}").push()
                            echo "‚¨ÜÔ∏è Pushing image ${IMAGE_NAME}:latest to Docker Hub..."
                            docker.image("${IMAGE_NAME}:${TAG}").push("latest") // Also tag as latest
                        }
                    }
                }
            }
        }

        stage('‚úèÔ∏è Update Deployment YAML') {
            steps {
                dir('config') {
                    script {
                        def filePath = "k8s/backend/deployment.yaml"
                        def newImage = "${IMAGE_NAME}:${TAG}"
                        echo "üîß Updating Kubernetes deployment YAML at ${filePath} to use image: ${newImage}"
                        // Using sed to replace the image line. Ensure your YAML structure matches.
                        // This assumes the image line looks like '        image: some-old-image:tag'
                        sh "sed -i 's|image:.*|        image: ${newImage}|' ${filePath}"
                        echo "Updated YAML content:"
                        sh "cat ${filePath}"
                    }
                }
            }
        }

        stage('üì§ Commit & Push Changes') {
            steps {
                dir('config') {
                    withCredentials([string(credentialsId: "${GITHUB_PUSH_TOKEN_ID}", variable: 'GIT_TOKEN')]) {
                        script {
                            echo "‚öôÔ∏è Configuring Git user for commit..."
                            sh """
                                git config user.email "rani.saed19@gmail.com"
                                git config user.name "Rani Saed (CI/CD Bot)"
                            """
                            echo " staging k8s/backend/deployment.yaml..."
                            sh "git add k8s/backend/deployment.yaml"

                            // Check if there are actual changes staged before committing
                            def changesToCommit = sh(
                                script: "git diff --cached --quiet || echo 'changes'",
                                returnStdout: true
                            ).trim()

                            if (changesToCommit == 'changes') {
                                echo "‚¨ÜÔ∏è Committing and pushing updated deployment YAML..."
                                sh "git commit -m \"üöÄ Update backend image to ${TAG}\""
                                // Use the token for pushing
                                sh "git remote set-url origin https://${GIT_TOKEN}@github.com/RaniSaed/smart-retail-config.git"
                                sh "git push origin main"
                                echo "‚úÖ Updated deployment YAML committed and pushed to smart-retail-config."
                            } else {
                                echo "‚ÑπÔ∏è No changes detected in k8s/backend/deployment.yaml to commit. Skipping commit and push."
                            }
                        }
                    }
                }
            }
        }

        stage('üõ°Ô∏è DR Failover & Sync Logic') {
            steps {
                script {
                    // --- 0. Pre-check: Ensure CI-Main-Backend (gogo-main-backend:5001) is running and healthy for seeding ---
                    // This is the CRITICAL source of truth for the DR backend's data.
                    echo "--- Step 0: Validating CI-Main Backend (gogo-main-backend:5001) health for DR seeding ---"
                    def ciMainBackendHealthCheckAttempts = 5
                    def ciMainBackendHealthWait = 10 // seconds
                    def ciMainBackendReady = false

                    for (int i = 1; i <= ciMainBackendHealthCheckAttempts; i++) {
                        echo "Attempt ${i}/${ciMainBackendHealthCheckAttempts}: Checking CI-Main Backend (gogo-main-backend:5001)..."
                        // Check if container is running
                        def ciMainBackendIsRunningCheck = sh(
                            script: "docker ps --filter 'name=gogo-main-backend' --format '{{.Names}}'",
                            returnStdout: true
                        ).trim() == 'gogo-main-backend'

                        if (ciMainBackendIsRunningCheck) {
                            // Check if health endpoint returns 200 OK
                            def ciMainBackendHealthyCheck = sh(
                                script: "curl -s -o /dev/null -w '%{http_code}' http://localhost:5001/health || true",
                                returnStdout: true
                            ).trim() == '200'

                            if (ciMainBackendHealthyCheck) {
                                echo "‚úÖ CI-Main Backend (gogo-main-backend:5001) is running and healthy."
                                ciMainBackendReady = true
                                break // Exit loop, backend is ready
                            } else {
                                echo "‚ö†Ô∏è CI-Main Backend (gogo-main-backend:5001) is running but UNHEALTHY (expected HTTP 200 from /health)."
                            }
                        } else {
                            echo "‚ùå CI-Main Backend container (gogo-main-backend:5001) is NOT running."
                        }

                        if (!ciMainBackendReady && i < ciMainBackendHealthCheckAttempts) {
                            echo "Retrying in ${ciMainBackendHealthWait} seconds..."
                            sleep ciMainBackendHealthWait
                        }
                    }

                    if (!ciMainBackendReady) {
                        env.CI_MAIN_BACKEND_PRECHECK_STATUS = "Failed - Not Healthy/Running"
                        error "CRITICAL: CI-Main Backend (gogo-main-backend:5001) is not healthy or not running after multiple attempts. Cannot proceed with DR seeding."
                    }
                    env.CI_MAIN_BACKEND_PRECHECK_STATUS = "Healthy and Running"


                    // --- 1. Seed DR Backend (gogo-dr-backend:5002) from CI-Main-Backend (5001) ---
                    echo "--- Step 1: Seeding DR Backend (gogo-dr-backend:5002) from CI-Main Backend (5001) ---"
                    echo "Ensuring no old 'gogo-dr-backend' container is running..."
                    sh "docker stop gogo-dr-backend || true" // Stop existing DR backend if any
                    sh "docker rm gogo-dr-backend || true"   // Remove it to ensure a clean run

                    echo "üöÄ Starting new 'gogo-dr-backend' container using image: ${DR_BACKEND_IMAGE} on port 5002..."
                    sh """
                        docker run --rm -d \
                        --name gogo-dr-backend \
                        -p 5002:5000 \
                        ${DR_BACKEND_IMAGE}
                    """
                    echo "Waiting 10 seconds for 'gogo-dr-backend' to initialize..."
                    sleep 10 // Give the container time to start up and expose its port

                    echo "üå± Executing seed.py inside 'gogo-dr-backend' container to sync data from http://localhost:5001 (CI-Main-Backend)..."
                    // IMPORTANT: The seed.py script inside your DR_BACKEND_IMAGE MUST be configured
                    // to pull data from http://localhost:5001. This assumes Jenkins agent network setup
                    // allows gogo-dr-backend to reach 5001 on localhost (which it typically does via host network or bridge with published ports).
                    def drBackendSeedSuccess = sh(
                        script: 'docker exec gogo-dr-backend python /app/seed.py', // Adjust path if seed.py is elsewhere
                        returnStatus: true
                    )

                    if (drBackendSeedSuccess == 0) {
                        echo "‚úÖ DR Backend seed.py executed successfully from CI-Main Backend (5001)."
                        env.DR_DATA_SYNC_STATUS = "DR Backend Seeded Successfully from 5001"
                        echo "üîç Performing health check on DR Backend (gogo-dr-backend:5002) after seeding..."
                        def drBackendHealthyAfterSeed = sh(
                            script: "curl -s -o /dev/null -w '%{http_code}' http://localhost:5002/health || true",
                            returnStdout: true
                        ).trim() == '200'

                        if (drBackendHealthyAfterSeed) {
                            echo "‚úÖ DR Backend (gogo-dr-backend:5002) is healthy after seeding."
                            // env.DR_BACKEND_STATUS will be set later based on frontend choice
                        } else {
                            echo "‚ùå DR Backend (gogo-dr-backend:5002) health check failed after seeding (expected HTTP 200)."
                            env.DR_BACKEND_STATUS = "DR Backend Seeded but Health Check Failed (5002)"
                            error "Critical: DR Backend failed health check after seeding. Pipeline halted."
                        }
                    } else {
                        echo "‚ùå DR Backend seed.py failed or could not connect to CI-Main Backend (5001)."
                        env.DR_DATA_SYNC_STATUS = "DR Backend Seed Failed from 5001"
                        error "CRITICAL: DR Backend data seeding failed from CI-Main Backend (5001). Pipeline halted."
                    }


                    // --- 2. Determine Frontend API URL (K8s-Backend 5000 preferred, else DR-Backend 5002) ---
                    def frontendApiUrl
                    echo "--- Step 2: Determining Frontend API URL ---"
                    echo "üîç Checking health of K8s Backend (http://localhost:5000/health)..."
                    // Note: Your original K8s backend health check was 'http://gogo-backend:5000/health'.
                    // For a Jenkins agent to reach it directly, it needs to be exposed on localhost,
                    // typically via kubectl port-forward or if Jenkins is running in the K8s cluster.
                    // Assuming for now, 'localhost:5000' is the access point from the Jenkins agent.
                    // If your K8s backend is truly accessed only via its internal K8s service name
                    // and Jenkins is *not* in the cluster or port-forwarding, this curl will fail.
                    // You might need 'kubectl exec' or a K8s client in Jenkins for proper K8s checks.
                    // For the sake of completing the logic as per your structure, I'll stick with localhost for direct curl.
                    def k8sBackendIsHealthy = sh(
                        script: "curl -s -o /dev/null -w '%{http_code}' http://localhost:5000/health || true",
                        returnStdout: true
                    ).trim() == '200'

                    if (k8sBackendIsHealthy) {
                        frontendApiUrl = "http://localhost:5000"
                        echo "‚úÖ K8s Backend (5000) is healthy. Frontend will be configured to use: ${frontendApiUrl}"
                        env.DR_BACKEND_STATUS = "K8s Backend (5000) Active" // For reporting
                    } else {
                        frontendApiUrl = "http://localhost:5002" // Fallback to DR Backend
                        echo "‚ùå K8s Backend (5000) is NOT healthy (expected HTTP 200). Frontend will be configured to use DR Backend: ${frontendApiUrl}"
                        env.DR_BACKEND_STATUS = "DR Backend (5002) Active" // For reporting
                    }
                    env.FRONTEND_API_URL_USED = frontendApiUrl // Store for post-build reporting


                    // --- 3. Determine Active Frontend (Main 3000 preferred, else DR 3002) ---
                    echo "--- Step 3: Determining Active Frontend ---"
                    def mainFrontendIsRunning = sh(
                        script: "docker ps --filter 'name=gogo-main-frontend' --format '{{.Names}}'",
                        returnStdout: true
                    ).trim() == 'gogo-main-frontend'

                    def mainFrontendIsHealthy = false
                    if (mainFrontendIsRunning) {
                        echo "üîç Checking health of Main Frontend (gogo-main-frontend:3000)..."
                        // Assuming frontend root (/) gives a 200 OK if healthy
                        def healthStatus = sh(script: "curl -s -o /dev/null -w '%{http_code}' http://localhost:3000 || true", returnStdout: true).trim() == '200'
                        mainFrontendIsHealthy = (healthStatus)
                        if (mainFrontendIsHealthy) {
                            echo "‚úÖ Main Frontend (gogo-main-frontend:3000) is running and healthy."
                        } else {
                            echo "‚ö†Ô∏è Main Frontend (gogo-main-frontend:3000) is running but unhealthy (expected HTTP 200 from /)."
                        }
                    } else {
                        echo "‚ùå Main Frontend container (gogo-main-frontend) is NOT running."
                    }

                    if (mainFrontendIsRunning && mainFrontendIsHealthy) {
                        // Main Frontend is currently active and healthy, prefer it.
                        env.ACTIVE_FRONTEND_NAME = "gogo-main-frontend"
                        env.ACTIVE_FRONTEND_PORT = "3000"
                        env.DR_FRONTEND_STATUS = "Main Active (3000)"

                        echo "Stopping any existing DR Frontend (gogo-dr-frontend)..."
                        sh "docker stop gogo-dr-frontend || true"
                        sh "docker rm gogo-dr-frontend || true"

                        echo "Reconfiguring and restarting Main Frontend (gogo-main-frontend) to connect to ${frontendApiUrl}..."
                        // Stop and remove to ensure fresh start with updated environment variables
                        sh "docker stop gogo-main-frontend || true"
                        sh "docker rm gogo-main-frontend || true"
                        sh """
                            docker run --rm -d \
                            --name gogo-main-frontend \
                            -p 3000:80 \
                            -e REACT_APP_API_URL=${frontendApiUrl} \
                            ${FRONTEND_IMAGE}
                        """
                        echo "Waiting 5 seconds for Main Frontend to restart..."
                        sleep 5
                        // Re-check health after restart
                        def recheckFrontendHealthy = sh(
                            script: "curl -s -o /dev/null -w '%{http_code}' http://localhost:3000 || true",
                            returnStdout: true
                        ).trim() == '200'
                        if (recheckFrontendHealthy) {
                            echo "‚úÖ Main Frontend restarted successfully and is healthy with new backend connection."
                        } else {
                            echo "‚ùå Main Frontend failed health check after restart/reconfiguration (expected HTTP 200)."
                            env.DR_FRONTEND_STATUS = "Main Active but Reconfig Failed"
                            error "Critical: Main Frontend failed health check after reconfiguring. Pipeline halted."
                        }

                    } else {
                        // Main Frontend is not active or unhealthy, initiate DR Frontend failover.
                        echo "üö® Main Frontend is not fully active or healthy. Initiating DR Frontend failover."
                        echo "Stopping any existing Main Frontend (gogo-main-frontend)..."
                        sh "docker stop gogo-main-frontend || true"
                        sh "docker rm gogo-main-frontend || true"

                        env.ACTIVE_FRONTEND_NAME = "gogo-dr-frontend"
                        env.ACTIVE_FRONTEND_PORT = "3002"
                        env.DR_FRONTEND_STATUS = "DR Activated (3002)"

                        echo "üöÄ Starting DR Frontend (gogo-dr-frontend) using image: ${FRONTEND_IMAGE} on port 3002..."
                        // Stop/remove in case it was started for seeding and not properly removed.
                        sh "docker stop gogo-dr-frontend || true"
                        sh "docker rm gogo-dr-frontend || true"
                        sh """
                            docker run --rm -d \
                            --name gogo-dr-frontend \
                            -p 3002:80 \
                            -e REACT_APP_API_URL=${frontendApiUrl} \
                            ${FRONTEND_IMAGE}
                        """
                        echo "Waiting 5 seconds for DR Frontend to start..."
                        sleep 5
                        echo "üîç Checking health of DR Frontend (gogo-dr-frontend:3002)..."
                        def drFrontendHealthy = sh(
                            script: "curl -s -o /dev/null -w '%{http_code}' http://localhost:3002 || true",
                            returnStdout: true
                        ).trim() == '200'
                        if (drFrontendHealthy) {
                            echo "‚úÖ DR Frontend (gogo-dr-frontend:3002) is healthy."
                            env.DR_FRONTEND_STATUS = "DR Activated & Healthy (3002)"
                        } else {
                            echo "‚ùå DR Frontend activated but Health Check Failed (3002) (expected HTTP 200)."
                            env.DR_FRONTEND_STATUS = "DR Activated but Health Check Failed (3002)"
                            error "Critical: DR Frontend failed health check after activation. Pipeline halted."
                        }
                    }

                    // If we reach here, the DR mechanism has successfully determined and launched the correct frontend/backend config.
                    env.DR_TEST_RESULT = "SUCCESS"
                    echo "üéâ DR Failover & Sync Logic completed successfully!"
                }
            }
        }
    }

    post {
        always {
            // Optional: Perform a general cleanup of all project-related Docker containers that are transient.
            // This ensures a clean slate for the next run and prevents orphaned containers.
            // Be cautious with this if you want some containers (like gogo-main-backend) to persist outside of pipeline runs.
            echo "--- Post-build cleanup (Stopping/Removing temporary containers managed by pipeline) ---"
            sh "docker stop gogo-main-frontend || true && docker rm gogo-main-frontend || true"
            sh "docker stop gogo-dr-frontend || true && docker rm gogo-dr-frontend || true"
            sh "docker stop gogo-dr-backend || true && docker rm gogo-dr-backend || true"
            // Note: gogo-main-backend (5001) and gogo-main-db (if used) are assumed to be managed externally
            // and should ideally not be stopped by the pipeline unless they are meant to be transient.
            echo "Cleanup complete."
        }
        success {
            echo "‚úÖ Pipeline executed successfully!"
            withCredentials([string(credentialsId: "${SLACK_CREDENTIAL_ID}", variable: 'SLACK_WEBHOOK')]) {
                sh """
                    curl -X POST -H 'Content-type: application/json' \
                    --data '{"text": "‚úÖ *Smart Retail CI/CD Success* (Build #${env.BUILD_NUMBER})\\n*Backend Image:* ${env.IMAGE_NAME}:${env.TAG}\\n*Active Frontend:* ${env.ACTIVE_FRONTEND_NAME} (${env.ACTIVE_FRONTEND_PORT})\\n*Backend API Used:* ${env.FRONTEND_API_URL_USED}\\n*DR Data Sync Status:* ${env.DR_DATA_SYNC_STATUS}\\n*Full Logs:* ${env.BUILD_URL}"}' $SLACK_WEBHOOK
                """
            }
        }

        aborted {
            echo "‚èπÔ∏è Pipeline aborted."
            withCredentials([string(credentialsId: "${SLACK_CREDENTIAL_ID}", variable: 'SLACK_WEBHOOK')]) {
                sh """
                    curl -X POST -H 'Content-type: application/json' \
                    --data '{"text": "‚ö†Ô∏è *Smart Retail CI/CD Aborted* (Build #${env.BUILD_NUMBER})\\nReason: No changes in backend code or manually aborted.\\n*Full Logs:* ${env.BUILD_URL}"}' $SLACK_WEBHOOK
                """
            }
        }

        failure {
            echo "‚ùå Pipeline failed."
            withCredentials([string(credentialsId: "${SLACK_CREDENTIAL_ID}", variable: 'SLACK_WEBHOOK')]) {
                sh """
                    curl -X POST -H 'Content-type: application/json' \
                    --data '{"text": "‚ùå *Smart Retail CI/CD FAILED* (Build #${env.BUILD_NUMBER})!\\n*CI-Main Backend Pre-check:* ${env.CI_MAIN_BACKEND_PRECHECK_STATUS}\\n*DR Data Sync:* ${env.DR_DATA_SYNC_STATUS}\\n*Active Frontend Status:* ${env.DR_FRONTEND_STATUS}\\n*Active Backend Status (based on frontend choice):* ${env.DR_BACKEND_STATUS}\\n*Frontend API URL Used:* ${env.FRONTEND_API_URL_USED}\\n*Full Logs:* ${env.BUILD_URL}"}' $SLACK_WEBHOOK
                """
            }
        }
    }
}