pipeline {
  agent any

  environment {
    IMAGE_NAME = 'rani19/backend'
    TAG = "build-${env.BUILD_NUMBER}"
    DEV_REPO_URL = 'https://github.com/RaniSaed/smart-retail-dev.git'
    CONFIG_REPO_URL = 'https://github.com/RaniSaed/smart-retail-config.git'
    DOCKER_CREDENTIALS_ID = 'docker-hub-creds'
    SLACK_WEBHOOK = credentials('slack-webhook')
    GIT_CREDENTIALS_ID = 'github-token'
  }

  options {
    buildDiscarder(logRotator(numToKeepStr: '5'))
    timeout(time: 20, unit: 'MINUTES')
  }

  stages {

    stage('ğŸ‘‹ Start') {
      steps {
        echo "ğŸš€ Pipeline started for: ${IMAGE_NAME}:${TAG}"
      }
    }

    stage('ğŸ“¥ Clone Dev Repo') {
      steps {
        dir('dev') {
          git url: "${DEV_REPO_URL}", branch: 'main'
        }
      }
    }

    stage('ğŸ“¥ Clone Config Repo') {
      steps {
        dir('config') {
          git url: "${CONFIG_REPO_URL}", branch: 'main', credentialsId: "${GIT_CREDENTIALS_ID}"
        }
      }
    }

    stage('ğŸ” Check Backend Changes') {
      steps {
        dir('dev') {
          script {
            def changed = sh(
              script: "git diff --name-only HEAD~1 HEAD | grep -q '^backend/'",
              returnStatus: true
            ) == 0

            if (!changed) {
              echo "âš ï¸ No changes in backend code. Skipping build..."
              currentBuild.result = 'ABORTED'
              error("No backend changes to build.")
            }
          }
        }
      }
    }

    stage('ğŸ³ Build Docker Image') {
      steps {
        dir('dev/backend') {
          script {
            sh "docker build -t ${IMAGE_NAME}:${TAG} ."
          }
        }
      }
    }

    stage('ğŸ“¤ Push to Docker Hub') {
      steps {
        script {
          docker.withRegistry('', "${DOCKER_CREDENTIALS_ID}") {
            sh "docker tag ${IMAGE_NAME}:${TAG} ${IMAGE_NAME}:latest"
            sh "docker push ${IMAGE_NAME}:${TAG}"
            sh "docker push ${IMAGE_NAME}:latest"
          }
        }
      }
    }

    stage('ğŸ“ Update Deployment YAML') {
      steps {
        dir('config/k8s/backend') {
          script {
            sh "sed -i 's|image: ${IMAGE_NAME}:.*|image: ${IMAGE_NAME}:${TAG}|' deployment.yaml"
          }
        }
      }
    }

    stage('âœ… Commit & Push Changes') {
      steps {
        dir('config') {
          script {
            sh 'git config user.name "Jenkins"'
            sh 'git config user.email "jenkins@example.com"'
            sh 'git add .'
            sh 'git commit -m "ğŸš€ Update backend image to tag ${TAG}" || echo "No changes to commit"'
            sh 'git push origin main'
          }
        }
      }
    }

    stage('âœ… Validate Primary Health') {
      steps {
        script {
          echo "ğŸ” Checking primary backend health via port-forward..."

          def pfProcess = sh(
            script: "kubectl port-forward svc/backend 5002:5000 -n default > /dev/null 2>&1 & echo \$!",
            returnStdout: true
          ).trim()

          sleep 5

          try {
            def response = sh(
              script: "curl -s -o /dev/null -w '%{http_code}' http://localhost:5002/api/products",
              returnStdout: true
            ).trim()

            if (response != '200') {
              error("âŒ Backend health check failed. HTTP $response")
            }
            echo "âœ… Backend is healthy! HTTP $response"
          } finally {
            sh "kill ${pfProcess} || true"
          }
        }
      }
    }

    stage('ğŸš€ Deploy to DR Region') {
      steps {
        echo "ğŸ—ºï¸ Deploying to DR Region (ArgoCD will detect new image)"
      }
    }

    stage('âœ… Validate DR Health') {
      steps {
        echo "ğŸ” Add curl check for DR later"
      }
    }

    stage('âš¡ Failover Test') {
      steps {
        echo "ğŸ§ª You can trigger failover-check.sh externally"
      }
    }

    stage('ğŸ“Š Generate DR Readiness Report') {
      steps {
        echo "ğŸ“„ You can generate report here"
      }
    }
  }

  post {
    failure {
      script {
        sh """
        curl -X POST -H 'Content-type: application/json' \
        --data '{"text": "âŒ *Backend* pipeline failed. Check Jenkins logs."}' ${SLACK_WEBHOOK}
        """
      }
    }
    success {
      script {
        sh """
        curl -X POST -H 'Content-type: application/json' \
        --data '{"text": "âœ… *Backend* pipeline succeeded. Image: ${IMAGE_NAME}:${TAG}"}' ${SLACK_WEBHOOK}
        """
      }
    }
  }
}
