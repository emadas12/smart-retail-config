// Jenkinsfile - Declarative Pipeline for Smart Retail Project with DR Failover

pipeline {
    agent any // Defines where the pipeline will run (any available agent)
    // Consider using a specific agent for better control and reproducibility:
    // agent { label 'my-docker-jenkins-agent' }

    environment {
        // --- Docker Configuration ---
        // Docker Hub organization/username
        DOCKER_HUB_ORG = 'rani19'
        // Docker image name for your backend service (assuming a convention like org/service-name)
        IMAGE_NAME = "${DOCKER_HUB_ORG}/backend"
        // Tag for the Docker image, incorporating the Jenkins build number for uniqueness
        TAG = "build-${env.BUILD_NUMBER}"

        // --- Repository URLs ---
        // URL for your development repository (backend code)
        DEV_REPO_URL = 'https://github.com/RaniSaed/smart-retail-dev.git'
        // URL for your configuration repository (Kubernetes manifests, etc.)
        CONFIG_REPO_URL = 'https://github.com/RaniSaed/smart-retail-config.git'

        // --- Jenkins Credential IDs ---
        // Jenkins credential ID for Docker Hub login (Username with Password)
        DOCKER_CREDENTIALS_ID = 'docker-hub-creds'
        // Jenkins credential ID for Slack webhook (Secret Text)
        SLACK_CREDENTIAL_ID = 'slack-webhook' // Ensure this ID matches your Jenkins credential

        // --- Health Check & Failover Configuration ---
        // These URLs match your `docker ps` output for localhost ports
        MAIN_BACKEND_HEALTH_URL = 'http://localhost:5001/health' // gogo-backend
        DR_BACKEND_HEALTH_URL = 'http://localhost:5002/health'   // gogo-dr-backend
        MAIN_FRONTEND_HEALTH_URL = 'http://localhost:3000'       // gogo-main-frontend
        DR_FRONTEND_HEALTH_URL = 'http://localhost:3002'         // gogo-dr-frontend

        // Docker container names from your `docker ps` output (for `docker exec`/`docker start`)
        MAIN_BACKEND_CONTAINER_NAME = 'gogo-backend'
        DR_BACKEND_CONTAINER_NAME = 'gogo-dr-backend'
        MAIN_FRONTEND_CONTAINER_NAME = 'gogo-main-frontend' // Added for clarity in DR logic
        DR_FRONTEND_CONTAINER_NAME = 'gogo-dr-frontend'     // Added for clarity in DR logic

        // Health check parameters
        HEALTH_CHECK_MAX_ATTEMPTS = 15 // Increased attempts for robustness
        HEALTH_CHECK_WAIT_TIME_SECONDS = 10 // Increased wait time between attempts
        HEALTH_CHECK_TOTAL_TIMEOUT_SECONDS = 180 // Total timeout (e.g., 3 minutes) for a health check cycle

        // Slack channel for notifications
        SLACK_CHANNEL = "#devops-alerts" // Customize your Slack channel here
    }

    options {
        // Keep only the last 5 successful builds and their logs, and artifacts from last 3
        buildDiscarder(logRotator(numToKeepStr: '5', artifactNumToKeepStr: '3'))
        // Set a global timeout for the entire pipeline to prevent indefinite runs
        timeout(time: 30, unit: 'MINUTES') // Increased from 20 to 30 mins
        // Prevent multiple instances of this pipeline from running concurrently
        disableConcurrentBuilds()
        // Add timestamps to console output for better readability
        timestamps()
        // Enable ANSI color codes in console output if AnsiColor plugin is installed
        ansiColor('xterm')
    }

    stages {
        stage('ðŸ“¥ Clone Repositories') {
            steps {
                // Clean the workspace thoroughly before cloning
                cleanWs(deleteDirs: true)

                echo "Cloning development repository: ${DEV_REPO_URL}"
                dir('dev') {
                    git url: "${DEV_REPO_URL}", branch: 'main'
                }

                echo "Cloning configuration repository: ${CONFIG_REPO_URL}"
                dir('config') {
                    git url: "${CONFIG_REPO_URL}", branch: 'main'
                }
            }
        }

        stage('ðŸ•µï¸ Check for Backend Changes') {
            steps {
                dir('dev') {
                    script {
                        // Check if the 'backend/' directory has changes in the latest commit
                        // git diff --name-only HEAD~1 HEAD gets files changed in the last commit
                        // grep -q checks silently if 'backend/' path is present
                        def backendChanged = sh(
                            script: "git diff --name-only HEAD~1 HEAD | grep -q '^backend/' || true", // || true to prevent shell from failing
                            returnStatus: true
                        ) == 0

                        if (!backendChanged) {
                            echo "âš ï¸ No changes detected in the 'backend/' directory since the last commit. Aborting pipeline."
                            currentBuild.result = 'ABORTED' // Set build status to ABORTED
                            error("No changes in backend/") // Terminate pipeline with an error message
                        } else {
                            echo "âœ… Changes detected in 'backend/'. Proceeding with build."
                        }
                    }
                }
            }
        }

        stage('ðŸ³ Build & Push Docker Image') {
            steps {
                dir('dev') {
                    script {
                        echo "ðŸ“¦ Building Docker image: ${IMAGE_NAME}:${TAG}"
                        // Build the Docker image from the backend/Dockerfile, using 'backend' as the context
                        docker.build("${IMAGE_NAME}:${TAG}", "-f backend/Dockerfile backend")
                    }
                }
                echo "ðŸš€ Pushing Docker image to Docker Hub..."
                // Use Docker Hub credentials securely for login and pushing
                withCredentials([usernamePassword(credentialsId: "${DOCKER_CREDENTIALS_ID}", usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                    docker.withRegistry("https://index.docker.io/v1/", "${DOCKER_CREDENTIALS_ID}") {
                        // Push the image with the unique build tag
                        docker.image("${IMAGE_NAME}:${TAG}").push()
                        echo "Pushed ${IMAGE_NAME}:${TAG}"
                        // Also push the same image with the 'latest' tag for convenience
                        docker.image("${IMAGE_NAME}:${TAG}").push("latest")
                        echo "Pushed ${IMAGE_NAME}:latest"
                    }
                }
            }
        }

        stage('âœï¸ Update Deployment YAML') {
            steps {
                dir('config') {
                    script {
                        def filePath = "k8s/backend/deployment.yaml" // Path to the Kubernetes deployment YAML
                        def newImage = "${IMAGE_NAME}:${TAG}"       // The new image tag to update
                        echo "ðŸ”§ Updating ${filePath} with new image: ${newImage}"

                        // Use Perl for cross-platform 'sed -i' behavior
                        // 's|image:.*|image: ${newImage}|g' replaces 'image:' followed by anything with the new image tag globally
                        sh "perl -pi -e 's|image:.*|image: ${newImage}|g' ${filePath}"
                        sh "echo '--- Updated file content ---'; cat ${filePath}" // Print for verification
                    }
                }
            }
        }

        stage('ðŸ“¤ Commit & Push Config Changes') {
            steps {
                dir('config') {
                    // Use GitHub personal access token for pushing changes
                    withCredentials([string(credentialsId: 'github-push-token', variable: 'GIT_TOKEN')]) {
                        script {
                            sh """
                                git config user.email "rani.saed19@gmail.com"
                                git config user.name "Rani Saed (CI/CD)"
                                git add k8s/backend/deployment.yaml # Stage the updated deployment YAML

                                # Check if there are actual changes staged before committing
                                if ! git diff --cached --quiet; then
                                    echo "Committing and pushing updated deployment YAML."
                                    git commit -m "ðŸš€ Update backend image to ${TAG}"
                                    # Set the remote URL with the token for authentication
                                    git remote set-url origin https://${GIT_TOKEN}@github.com/RaniSaed/smart-retail-config.git
                                    git push origin main
                                else
                                    echo "No changes to commit in config repository."
                                fi
                            """
                        }
                    }
                }
            }
        }

        stage('â¤ï¸ Health Check & DR Failover Logic') {
            steps {
                script {
                    // Reusable health check function
                    def checkHealth = { serviceName, url ->
                        echo "ðŸ”Ž Checking ${serviceName} health at ${url}..."
                        def success = false
                        def startTime = System.currentTimeMillis()
                        def totalTimeoutMs = env.HEALTH_CHECK_TOTAL_TIMEOUT_SECONDS as int * 1000

                        while (System.currentTimeMillis() - startTime < totalTimeoutMs && !success) {
                            def responseCode = sh(
                                script: "curl -s -o /dev/null -w '%{http_code}' --max-time 10 ${url} || echo 000",
                                returnStdout: true
                            ).trim()

                            // For backend, check for specific 'healthy' status; for frontend, check 200/30x
                            if (serviceName.contains('Backend')) {
                                // Try to get the actual health status from the response body
                                def healthResponseBody = sh(
                                    script: "curl -s --max-time 10 ${url} || true", // || true to prevent curl errors from failing this sh step
                                    returnStdout: true
                                ).trim()
                                def statusKeywordFound = (healthResponseBody =~ /"status"\s*:\s*"healthy"/).find()

                                if (responseCode == '200' && statusKeywordFound) {
                                    echo "âœ… ${serviceName} is healthy (HTTP ${responseCode}, status: healthy)."
                                    success = true
                                } else {
                                    echo "âŒ ${serviceName} not yet healthy (HTTP ${responseCode}, response: '${healthResponseBody.take(50)}...'). Retrying in ${env.HEALTH_CHECK_WAIT_TIME_SECONDS}s..."
                                }
                            } else { // For frontends
                                if (["200", "301", "302"].contains(responseCode)) {
                                    echo "âœ… ${serviceName} is healthy (HTTP ${responseCode})."
                                    success = true
                                } else {
                                    echo "âŒ ${serviceName} not yet healthy (HTTP ${responseCode}). Retrying in ${env.HEALTH_CHECK_WAIT_TIME_SECONDS}s..."
                                }
                            }

                            if (!success) {
                                sleep env.HEALTH_CHECK_WAIT_TIME_SECONDS as int
                            }
                        }
                        return success // Return boolean indicating health status
                    }

                    // Store primary service health status
                    env.mainBackendHealthy = checkHealth("Main Backend", MAIN_BACKEND_HEALTH_URL).toString()
                    env.mainFrontendHealthy = checkHealth("Main Frontend", MAIN_FRONTEND_HEALTH_URL).toString()

                    // --- Failover Decision ---
                    if (env.mainBackendHealthy == 'false' || env.mainFrontendHealthy == 'false') {
                        echo "ðŸš¨ Primary services are DOWN. Initiating DR Failover procedures."
                        currentBuild.result = 'UNSTABLE' // Mark build as unstable if primary is down but DR takes over

                        // Step 1: Ensure DR containers are started
                        echo "Starting DR Backend container: ${DR_BACKEND_CONTAINER_NAME}..."
                        sh "docker start ${DR_BACKEND_CONTAINER_NAME} || true" // Start if not running
                        echo "Starting DR Frontend container: ${DR_FRONTEND_CONTAINER_NAME}..."
                        sh "docker start ${DR_FRONTEND_CONTAINER_NAME} || true" // Start if not running

                        // Step 2: Verify DR Backend health
                        def drBackendOk = checkHealth("DR Backend", DR_BACKEND_HEALTH_URL)
                        if (!drBackendOk) {
                            error "Critical: DR Backend failed to become healthy after primary failure. Aborting pipeline!"
                        }
                        echo "âœ… DR Backend confirmed healthy."

                        // Step 3: Run the seed command on the *DR Backend* for data synchronization
                        echo "Executing data seeding on DR Backend (${DR_BACKEND_CONTAINER_NAME})..."
                        // Note: changed from gogo-backend to gogo-dr-backend for the seed command
                        sh "docker exec -i ${DR_BACKEND_CONTAINER_NAME} bash -c 'python /app/seed.py'"
                        echo "Data seeding on DR Backend completed."

                        // Step 4: Verify DR Frontend health
                        def drFrontendOk = checkHealth("DR Frontend", DR_FRONTEND_HEALTH_URL)
                        if (!drFrontendOk) {
                            error "Critical: DR Frontend failed to become healthy after primary failure. Aborting pipeline!"
                        }
                        echo "âœ… DR Frontend confirmed healthy."

                        // Step 5: Notify about DR activation
                        slackSend(
                            channel: SLACK_CHANNEL,
                            color: 'danger',
                            message: "ðŸš¨ *Disaster Recovery Activated!* Primary services are down. DR services verified healthy and backend seeded. *Build*: ${env.BUILD_URL}"
                        )
                        echo "âš ï¸ Failover complete. Manual intervention or external automation may be needed to re-route traffic to DR services."

                    } else {
                        echo "âœ… Primary services are healthy. No DR activation needed."
                    }
                }
            }
        }
    }

    // Post-build actions: cleanup and notifications based on pipeline result
    post {
        always {
            echo "--- ðŸ§¹ Cleaning up ---"
            // Bring down Docker Compose services gracefully (assuming you use docker-compose outside this pipeline)
            // If the services are kept running by a separate 'docker compose up -d', you might not want to tear them down here.
            // If this pipeline is responsible for their lifecycle, then keep this.
            // sh "docker compose down --remove-orphans || true" // Use || true to prevent failure if already down

            // Kill any lingering kubectl port-forward processes (if you are running any, not shown in current docker ps)
            sh "pkill -f \"kubectl port-forward\" || true"

            // Clean the workspace completely for the next build
            echo "Cleaning Jenkins workspace..."
            cleanWs(deleteDirs: true)
        }

        success {
            script {
                // Check if DR was activated (mainBackendHealthy was 'false')
                if (env.mainBackendHealthy == 'false' || env.mainFrontendHealthy == 'false') {
                    echo "âœ… Pipeline completed successfully with DR activated."
                    // Specific DR success message was already sent in the 'Health Check & DR Failover' stage.
                } else {
                    echo "âœ… Backend image pushed and deployment updated. Services are healthy."
                    // Send success notification to Slack for a normal successful deployment
                    slackSend(
                        channel: SLACK_CHANNEL,
                        color: 'good', // Green for success
                        message: "âœ… *Backend CI/CD Success*: Image *${TAG}* pushed, K8s config updated, and services healthy. *Build*: ${env.BUILD_URL}"
                    )
                }
            }
        }

        aborted {
            echo "â¹ï¸ Pipeline aborted (due to no backend changes detected)."
            // Send aborted notification to Slack
            slackSend(
                channel: SLACK_CHANNEL,
                color: 'warning', // Yellow for aborted
                message: "âš ï¸ *Backend CI/CD Aborted*: No changes detected in 'backend/' directory. *Build*: ${env.BUILD_URL}"
            )
        }

        failure {
            echo "âŒ Pipeline failed at one or more stages."
            // Send failure notification to Slack
            slackSend(
                channel: SLACK_CHANNEL,
                color: 'danger', // Red for failure
                message: "âŒ *Backend CI/CD FAILED*: Pipeline for *${env.JOB_NAME} #${env.BUILD_NUMBER}* failed! Check logs: ${env.BUILD_URL}"
            )
        }
    }
}